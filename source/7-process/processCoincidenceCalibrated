#include <iostream>
#include <string>
#include <TTree.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TFile.h>
#include <TCanvas.h>
#include <vector>
#include <TMatrixT.h>

// int MinimumGroupSize = 64;
using namespace std;


std::vector<TCanvas *> processCoincidenceCalibrated(std::string fileName, int groupSize)
{

    // cria as variaveis nescessárias à leitura do arquivo root
    UShort_t mh_n1{0}, mh_j1{0}, mh_n2{0}, mh_j2{0};
    UInt_t channelID1{0}, channelID2{0};
    Float_t energy1{0.0}, energy2{0};
    Long64_t time1{0}, time2{0};
    std::vector<TString> ports;

    std::vector<Long64_t> timeChanels1(64, 0);
    std::vector<Float_t> energyChannels1(64, 0);
    std::vector<Long64_t> timeChanels2(64, 0);
    std::vector<Float_t> energyChannels2(64, 0);

    // abre o arquivo root
    TFile *file = new TFile(fileName.c_str(), "read");
    TTree *tree = nullptr;
    tree = (TTree *)file->Get("data");

    // set branches
    tree->SetBranchAddress("mh_n1", &mh_n1);
    tree->SetBranchAddress("mh_j1", &mh_j1);
    tree->SetBranchAddress("channelID1", &channelID1);
    tree->SetBranchAddress("energy1", &energy1);
    tree->SetBranchAddress("time1", &time1);
    tree->SetBranchAddress("mh_n2", &mh_n2);
    tree->SetBranchAddress("mh_j2", &mh_j2);
    tree->SetBranchAddress("channelID2", &channelID2);
    tree->SetBranchAddress("energy2", &energy2);
    tree->SetBranchAddress("time2", &time2);

    // declaracao dos histogramas;

    std::vector<TCanvas *> Canvas;

    int detNum = 2;
    int channelsPerArray = 64;

    // inicializa os histogramas de energia por canal;
    vector<vector<TH1F *>> chanellHistogram;
    vector<TH1F *> GlobalEnergy;
    vector<TH1F *> depthOfInteraction;
    vector<TH2F *> FloodHist;
    int bins = 250;
    Float_t eMin = -10;
    Float_t eMax = 50;
    SiPM sipm_tools;

    Configurations c("/home/aquisicao/Documentos/PET_SYS/ROOT/configuracoes/conf.conf", "/home/aquisicao/Documentos/PET_SYS/ROOT/configuracoes/PETSYS4CalSUM.conf");

    //auto correctionFactor = c.getCorrectionFactors(); // fatores de correção para linearidade
    auto hmin = c.gethMins();
    auto hmax = c.gethMaxs();
    auto detectorName = c.getName();
    auto chpid = c.getChipIDs();
    auto myType = c.getType();
    auto calibration = c.getCalibration();
    auto calibrationPETSYS = c.getCalibrationPETSYS();

    
    vector<int> inCoincidenceWith = c.getInCoincidenceWith();
    vector<TMatrixT<double>> Sipm;
    
    
    
    // inicializa os histogramas em cada posição do vetor
    for (int detector = 0; detector < detNum; detector++)
    {

        Sipm.push_back(TMatrixT<double>(8, 8));
        vector<TH1F *> auxHistChan;
        for (int chan = 0; chan < channelsPerArray; chan++)
        {
            string channelName{"channel-"};
            channelName = channelName + std::to_string(chan) + std::string(detectorName[detector].c_str());
            TH1F *myHisto = new TH1F(channelName.c_str(), channelName.c_str(), bins, hmin[detector], hmax[detector]);
            auxHistChan.push_back(myHisto);
            std::cout << "initializing histogram : " << channelName << std::endl;
        }

        string globalName = std::string(detectorName[detector].c_str());
        TH1F *myglobalHisto = new TH1F(globalName.c_str(), globalName.c_str(), bins, hmin[detector], hmax[detector]);
        std::string floodName = globalName + "flood";
        TH2F *flood = new TH2F(floodName.c_str(), floodName.c_str(), 256, -13.44, 13.44, 256, -13.44, 13.44);
        std::string DoiName = globalName + "- Doi";
        TH1F *myDoi = new TH1F(DoiName.c_str(), DoiName.c_str(), 256, 0, 3);

        depthOfInteraction.push_back(myDoi);
        GlobalEnergy.push_back(myglobalHisto);
        FloodHist.push_back(flood);
        chanellHistogram.push_back(auxHistChan);
    }

    int pos1 = 0;
    int pos2 = 0;
    float esum1 = 0;
    float esum2 = 0.0;
    Long64_t counting = 0;
    std::string loading = "[--------------------------------------------------]";
    int load_pos = 1;
    bool first = true;
    const int entries = tree->GetEntries();
    int initial_event{0}, ini_n1{0}, ini_n2{0};

    // Processa o nome da string de entrada
    auto name = splitString(fileName, '/');
    auto name_pos = name.size();
    string outName = name[name_pos - 1];
    name = splitString(outName, '.');
    name_pos = name.size();
    outName = name[0];
    outName = outName + "_Calibrated.root";

    // cria a classe responsável pela escrita
    GimnWrite Output(outName.c_str());

    float e1_first =0;
    float e2_first = 0;
    unsigned int coincidenceID{1};
    for (Int_t event = 0; event <= entries; event++)
    {
        // std::cout << " *******************************************  " << std::endl;
        //std::cout << " Event  " << event << std::endl;
        tree->GetEntry(event);

        Int_t chipID1 = (int)channelID1 / 64;
        Int_t channel1 = channelID1 - 64 * chipID1;

        Int_t chipID2 = (int)channelID2 / 64;
        Int_t channel2 = channelID2 - 64 * chipID2;


        // Linearization 
        Float_t P0      = calibrationPETSYS[chipID1][channel1][0];        
        Float_t P1      = calibrationPETSYS[chipID1][channel1][1];
        Float_t P2      = calibrationPETSYS[chipID1][channel1][2];        
        Float_t P3      = calibrationPETSYS[chipID1][channel1][3];
        
        auto energy1_2 = P0*pow(P1,pow(energy1,P2))+P3*energy1-P0;
        
        P0      = calibrationPETSYS[chipID2][channel2][0];        
        P1      = calibrationPETSYS[chipID2][channel2][1];
        P2      = calibrationPETSYS[chipID2][channel2][2];        
        P3      = calibrationPETSYS[chipID2][channel2][3];

        auto energy2_2 =P0*pow(P1,pow(energy2,P2))+P3*energy2-P0;


        // Calibration 

        Float_t slope = calibration[chipID1][channel1][0];        
        Float_t intercept = calibration[chipID1][channel1][1];
        energy1_2 =slope*energy1_2+intercept;

        slope = calibration[chipID2][channel2][0];        
        intercept = calibration[chipID2][channel2][1];
        energy2_2 =slope*energy2_2+intercept;

        //cout<<energy1_2<<endl;
        //cout<<energy2_2<<endl;

        if (event > ((entries / 50.0) * load_pos))
        {
                    
            auto porcento = ((double)event / (double)entries) * 100;
            auto clear = system("clear");
            loading[load_pos] = '=';
            std::cout << loading << porcento << "%" << std::endl;
            load_pos += 1;
        }

        // std::cout << " Mh_j1  " << mh_j1 << std::endl;
        // std::cout << " Mh_j2  " << mh_j2 << std::endl;

        // std::cout << " chipID  " << chipID << std::endl;
        // std::cout << " channel  " << channel << std::endl;

        // pega a posição do chipID 1 no vetor de detectores
      

        if ((mh_n1 > groupSize) && (mh_n2 > groupSize))
        {




            auto it = std::find(chpid.begin(), chpid.end(), chipID1);
            if (it != chpid.end())
                pos1 = std::distance(chpid.begin(), it);

            // pega a posição do chipID 2 no vetor de detectores
            it = std::find(chpid.begin(), chpid.end(), chipID2);
            if (it != chpid.end())
                pos2 = std::distance(chpid.begin(), it);

            if (chipID2 == inCoincidenceWith[pos1])
            {
                auto pos_xy1 = CorrectChannelToPixelPs(channel1);
                auto pos_xy2 = CorrectChannelToPixelPs(channel2);

                GimnEvent event_seg;

                if (mh_j1 == 0 && mh_j2 == 0)
                {
                    chanellHistogram[pos1][channel1]->Fill(energy1_2);
                    chanellHistogram[pos2][channel2]->Fill(energy2_2);
                    coincidenceID++;
                    initial_event = event;
                    ini_n1 = mh_n1;
                    ini_n2 = mh_n2;

                    e1_first = energy1_2;
                    e2_first = energy2_2;


                    Sipm[pos1](pos_xy1[1], pos_xy1[0]) = +energy1_2;
                    Sipm[pos2](pos_xy2[1], pos_xy2[0]) = +energy2_2;

                    timeChanels1[channel1] = time1;
                    energyChannels1[channel1] = energy1;
                    timeChanels2[channel2] = time2;
                    energyChannels2[channel2] = energy2;

                    std::vector<Float_t> xPos = sipm_tools.getPositionsX();
                    std::vector<Float_t> yPos = sipm_tools.getPositionsY();

                    if ((myType[pos1] == "seg") && (myType[pos2] == "seg"))
                    {
                        
                        event_seg.Energy_1 = energy1_2;
                        event_seg.time_1 = time1;
                        event_seg.xmm_1 = xPos[pos_xy1[0]];
                        event_seg.ymm_1 = yPos[pos_xy1[1]];
                        event_seg.doi_1 = 0.0;
                        event_seg.Port_1 = chpid[pos1];
                        event_seg.sipmX_1 = pos_xy1[0];
                        event_seg.sipmY_1 = pos_xy1[1];
                        event_seg.channel_1 = channel1;
                        //std::cout<<"group1"<<event_seg.Energy_1<<endl;
                        GlobalEnergy[pos1]->Fill(event_seg.Energy_1);
                        depthOfInteraction[pos1]->Fill(event_seg.doi_1);
                        FloodHist[pos1]->Fill(event_seg.xmm_1, event_seg.ymm_1);

                        event_seg.Energy_2 = energy2_2;
                        event_seg.time_2 = time2;
                        event_seg.xmm_2 = xPos[pos_xy2[0]];
                        event_seg.ymm_2 = yPos[pos_xy2[1]];
                        event_seg.doi_2 = 0.0;
                        event_seg.Port_2 = chpid[pos2];
                        event_seg.sipmX_2 = pos_xy2[0];
                        event_seg.sipmY_2 = pos_xy2[1];
                        event_seg.channel_2 = channel2;
                        event_seg.coincidenceID=coincidenceID;
                        GlobalEnergy[pos2]->Fill(event_seg.Energy_2);
                        depthOfInteraction[pos2]->Fill(event_seg.doi_2);
                        FloodHist[pos2]->Fill(event_seg.xmm_2, event_seg.ymm_2);

                        //std::cout<<"Event Energy "<<event_seg.Energy_1<<std::endl;
                        Output.putData(event_seg);

                        //std::cout<<" saving segmented event in a tree"<<std::endl;

                    
                    }

                    // cout<<"evento "<<event<<endl;
                    // cout<<"evento inicial "<<initial_event<<endl;
                    // cout<<"mh_n1 "<<mh_n1<<endl;
                    // cout<<"mh_n2 "<<mh_n2<<endl;
                    // cout<<"evento final"<<initial_event+(ini_n1+ini_n2)-2<<endl;
                coincidenceID++;
                } // indica o começo de uma nova coincidencia

                if (mh_j1 != 0 && mh_j2 == 0)
                {
                    Sipm[pos1](pos_xy1[1], pos_xy1[0]) = +energy1_2;
                    timeChanels1[channel1] = time1;
                    energyChannels1[channel1] = energy1_2;
                } // adiciona no grupo 1

                if (mh_j1 == 0 && mh_j2 != 0)
                {
                    Sipm[pos2](pos_xy2[1], pos_xy2[0]) = +energy2_2;
                    timeChanels2[channel2] = time2;
                    energyChannels2[channel2] = energy2_2;
                } // adiciona no grupo 1

                //
                //      AQUI é onde os dados são salvos no arquivo de saida.
                //
                //
                if (event == (initial_event + (ini_n1 + ini_n2) - 2))
                {

                    GimnEvent ev;

                    // ev. CTR
                    // ev. channel_1
                    //divideMatrix(Sipm[pos1], correctionFactor[pos1]);


                    auto Positions3D = anger(Sipm[pos1]);
                    ev.Energy_1 = e1_first;//Sipm[pos1].Sum();
                    ev.time_1 = tea(timeChanels1, energyChannels1);
                    ev.xmm_1 = Positions3D[0];
                    ev.ymm_1 = Positions3D[1];
                    ev.doi_1 = 0;//Positions3D[2];
                    ev.Port_1 = chpid[pos1];
                    ev.sipmX_1 = 0;
                    ev.sipmY_1 = 0;

                    //divideMatrix(Sipm[pos2], correctionFactor[pos2]);
                    Positions3D = anger(Sipm[pos2]);
                    ev.channel_2 = 0;
                    ev.Energy_2 = e2_first;//Sipm[pos2].Sum();
                    ev.time_2 = tea(timeChanels2, energyChannels2);

                    ev.xmm_2 = Positions3D[0];
                    ev.ymm_2 = Positions3D[1];
                    ev.doi_2 = 0;//Positions3D[2];
                    ev.Port_2 = chpid[pos2];
                    ev.sipmX_2 = 0;
                    ev.sipmY_2 = 0;
                    ev.coincidenceID = coincidenceID;

                    ev.CTR = abs(ev.time_1 - ev.time_2);


 
                    bool out1 = false;
                    bool out2 = false;
                    if ((ev.xmm_1 < 13.44 || ev.xmm_1 > -13.44) && (ev.ymm_1 < 13.44 || ev.ymm_1 > -13.44)){
                        {
                            out1 = true;
                            GlobalEnergy[pos1]->Fill(ev.Energy_1);//Sipm[pos1].Sum());
                            depthOfInteraction[pos1]->Fill(ev.doi_1);
                            FloodHist[pos1]->Fill(ev.xmm_1, ev.ymm_1);
                        }
                    }
                    if ((ev.xmm_2 < 13.44 && ev.xmm_2 > -13.44) && (ev.ymm_2 < 13.44 && ev.ymm_2 > -13.44)){
                        
                        {
                            out2 = true;

                            GlobalEnergy[pos2]->Fill(ev.Energy_1);//Sipm[pos2].Sum());
                            depthOfInteraction[pos2]->Fill(ev.doi_2);
                            FloodHist[pos2]->Fill(ev.xmm_2, ev.ymm_2);
                        }
                    }
                    if (!((out1 == false) && (out2 == false)))
                    {
                    if ((myType[pos1] == "mono") && (myType[pos2] == "mono")){
                            Output.putData(ev);               
                            
                            //std::cout<<"printing"<<std::endl;
                    }
                    }

                    

                    Sipm[pos1].Zero();
                    Sipm[pos2].Zero();
                    // cout<<"evento "<<event<<endl;
                    // cout<<"evento inicial "<<initial_event<<endl;
                    // cout<<"evento final"<<initial_event+(ini_n1+ini_n2)-2<<endl;
                } // ultimo evento
            }
        }
    }

    Canvas.push_back(new TCanvas("Detector1", "Detector1", 4000, 4000));
    Canvas.push_back(new TCanvas("Detector2", "Detector2", 4000, 4000));
    Canvas.push_back(new TCanvas("Detector3", "Detector3", 4000, 4000));
    Canvas.push_back(new TCanvas("Detector4", "Detector4", 4000, 4000));
    Canvas.push_back(new TCanvas("Global Energy", "Global Energy", 4000, 4000));
    Canvas.push_back(new TCanvas("Floods", "Floods", 4000, 4000));
    Canvas.push_back(new TCanvas("Doi", "Doi", 4000, 4000));

    for (Int_t i = 0; i < detNum; i++)
    {
        // std::string canvasName = (std::string)ports[i].Data()+ "Channel MAP";
        // Canvas.push_back(new TCanvas(ports[i].Data(),canvasName.c_str(),4000,4000));
        Canvas[i]->Divide(8, 8);
        for (Int_t channels = 0; channels < channelsPerArray; channels++)
        {
            auto pos_yx = CorrectChannelToPixelPs(channels);

            Canvas[i]->cd((pos_yx[1] * 8 + pos_yx[0]) + 1);
            chanellHistogram[i][channels]->Draw("HIST");
        }
        // std::string saveAs = (std::string)ports[i].Data()+ "ChannelMAP.png";
        Canvas[i]->Draw(); // Print(saveAs.c_str());
    }

 
    Canvas[2]->Divide(2, 2);
    Canvas[2]->cd(1);
    GlobalEnergy[0]->Draw("L");
    Canvas[2]->cd(2);
    GlobalEnergy[1]->Draw("L");
    Canvas[2]->cd(3);
    FloodHist[0]->Draw("COLZ");
    //GlobalEnergy[2]->Draw("L");
    Canvas[2]->cd(4);
    FloodHist[1]->Draw("COLZ");
    
    //GlobalEnergy[3]->Draw("L");
    Canvas[2]->Draw();

    //Canvas[3]->Divide(2, 2);
    //Canvas[3]->cd(1);
    //FloodHist[0]->Draw("COLZ");
    //Canvas[3]->cd(2);
    //FloodHist[1]->Draw("COLZ");
    //Canvas[3]->cd(3);
    //FloodHist[2]->Draw("COLZ");
    //Canvas[3]->cd(4);
    //FloodHist[3]->Draw("COLZ");
    //Canvas[3]->Draw();

    Canvas[4]->Divide(2, 1);
    Canvas[4]->cd(1);
    depthOfInteraction[0]->Draw("L");
    Canvas[4]->cd(2);
    depthOfInteraction[1]->Draw("L");
    //Canvas[4]->cd(3);
    //depthOfInteraction[2]->Draw("L");
    //Canvas[4]->cd(4);
    //depthOfInteraction[3]->Draw("L");
    Canvas[4]->Draw();
    
    Output.writeObject(chanellHistogram, GlobalEnergy, depthOfInteraction, FloodHist, detectorName, chpid, Canvas);
    Output.close();
    return Canvas;
}
